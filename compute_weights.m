%% compute_weights
% Author: Jan Glaubitz 
% Date: June 22, 2021 
%
% Compute the the RBF-CF weights 
%
%  INPUT: 
%  a, b :   left and right boundary of the domain 
%  rbf :    radial basis function 
%  ep :     shape parameter 
%  X :      data points 
%  m_RBF :  moments of the RBFs 
%  d : maximum degree of included polynomials 
%  precision : precision used in the computation
%
%  OUTPUT:
%  w :      quadrature weights (moments of cardinal functions)

%%
function w = compute_weights( a, b, rbf, ep, X, m_RBF, d, precision )
    
    % Define decision with which weights are computed 
    digits(precision);
    
    [N,dim] = size(X); % number of data points 
    DM = DistanceMatrix(X,X); % matrix with distances between points 
    V_rbf = rbf(ep',DM); % Vandermonde matrix
    
    %% no polynomials included
    if d < 0 
        
        %% weights 
        if precision~=32 
            w = vpa(V_rbf)\vpa(m_RBF); 
        else 
            w = V_rbf\m_RBF; 
        end
        
    %% polynomials included     
    else
        
        K = nchoosek(dim+d,dim); % number of basis functions
        
        if dim==1
            % define the polynomial basis p_0,...,p_d 
            if d == 0
                P = X.^0; % Polynomial matrix P
                m_poly = b-a; % moments 
            elseif d == 1
                P = [X.^0 , X]; % Polynomial matrix P
                m_poly = [b-a; (b^2-a^2)/2]; % moments 
            elseif d == 2
                P = [X.^0 , X , X.^2]; % Polynomial matrix P
                m_poly = [b-a; (b^2-a^2)/2; (b^3-a^3)/3]; % moments 
            else 
                'd to large';
            end
            
        elseif dim==2  
            % define the polynomial basis p_1,...,p_K 
            if d == 0
                P = ones(N,1); % Polynomial matrix P
                
                m_poly = (b-a).^2; % moments 
                
            elseif d == 1
                P = [ ones(N,1), X(:,1), X(:,2) ]; % Polynomial matrix P
                
                m_poly = [(b-a).^2; (b-a)*(b^2-a^2)/2; (b-a)*(b^2-a^2)/2]; % moments
                
            elseif d == 2
                P = [ ones(N,1), ...
                      X(:,1), ... 
                      X(:,2), ... 
                      X(:,1).^2, ... 
                      X(:,1).*X(:,2), ... 
                      X(:,2).^2 ]; % Polynomial matrix P
                  
                m_poly = [ (b-a).^2; ... 
                           (b-a)*(b^2-a^2)/2; ... 
                           (b-a)*(b^2-a^2)/2; ...
                           (b-a)*(b^3-a^3)/3; ... 
                           (b^2-a^2)^2/4; ...
                           (b-a)*(b^3-a^3)/3 ]; % moments 
                       
            elseif d == 3
                P = [ ones(N,1), ...
                      X(:,1), ... 
                      X(:,2), ... 
                      X(:,1).^2, ... 
                      X(:,1).*X(:,2), ... 
                      X(:,2).^2, ...          
                      X(:,1).^3, ...
                      (X(:,1).^2).*(X(:,2).^1), ...
                      (X(:,1).^1).*(X(:,2).^2), ...
                      X(:,2).^3 ]; % Polynomial matrix P
                  
                m_poly = [ (b-a).^2; ... 
                           (b-a)*(b^2-a^2)/2; ... 
                           (b-a)*(b^2-a^2)/2; ...
                           (b-a)*(b^3-a^3)/3; ... 
                           (b^2-a^2)^2/4; ...
                           (b-a)*(b^3-a^3)/3; ...            
                           (b^4-a^4)/4*(b^1-a^1)/1; ...
                           (b^3-a^3)/3*(b^2-a^2)/2; ...
                           (b^2-a^2)/2*(b^3-a^3)/3; ...
                           (b^1-a^1)/1*(b^4-a^4)/4 ]; % moments 
                       
            elseif d == 4
                P = [ ones(N,1), ...
                      X(:,1), ... 
                      X(:,2), ... 
                      X(:,1).^2, ... 
                      X(:,1).*X(:,2), ... 
                      X(:,2).^2, ...           
                      X(:,1).^3, ...
                      (X(:,1).^2).*(X(:,2).^1), ...
                      (X(:,1).^1).*(X(:,2).^2), ...
                      X(:,2).^3, ...                       
                      (X(:,1).^4).*(X(:,2).^0), ...
                      (X(:,1).^3).*(X(:,2).^1), ...
                      (X(:,1).^2).*(X(:,2).^2), ...
                      (X(:,1).^1).*(X(:,2).^3), ...
                      (X(:,1).^0).*(X(:,2).^4) ]; % Polynomial matrix P
                      
                m_poly = [ (b-a).^2; ... 
                           (b-a)*(b^2-a^2)/2; ... 
                           (b-a)*(b^2-a^2)/2; ...
                           (b-a)*(b^3-a^3)/3; ... 
                           (b^2-a^2)^2/4; ...
                           (b-a)*(b^3-a^3)/3; ...            
                           (b^4-a^4)/4*(b^1-a^1)/1; ...
                           (b^3-a^3)/3*(b^2-a^2)/2; ...
                           (b^2-a^2)/2*(b^3-a^3)/3; ...
                           (b^1-a^1)/1*(b^4-a^4)/4; ...             
                           (b^5-a^5)/5*(b^1-a^1)/1; ...
                           (b^4-a^4)/4*(b^2-a^2)/2; ...
                           (b^3-a^3)/3*(b^3-a^3)/3; ...
                           (b^2-a^2)/2*(b^4-a^4)/4; ...
                           (b^1-a^1)/1*(b^5-a^5)/5 ]; % moments 
                       
            else 
                'd to large';
            end
            
        else 
            error('Desired dimension not yet implemented')
        end 
        
        % Matrix A = ( V P ; P^T 0 )
        A = [ V_rbf P; P' zeros(K,K) ];
        
        % Auxilary vector and weights 
        %% weights 
        if precision~=32 
            v = vpa(A)\[vpa(m_RBF); vpa(m_poly)];
        else 
            v = A\[m_RBF; m_poly];
        end
        w = v(1:N);
        
    end

    % restore original precision
    digits(32);
    
end